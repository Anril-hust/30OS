
#include "asmhead.h"
#include "funcUtils.h"
#include "graphic.h"
#include "globalTbl.h"
#include "interrupt.h"
#include "dataStruct.h"
#include "mouse_keyboard.h"
#include "mem.h"
#include "tim.h"
#include "multiTask.h"
#include "wnd_console.h"
#include "cmd.h"

#include "stdio.h"

extern uint8 icon_heart[256];
extern TIM_CTL timerCtl;
extern SHEET_CTL sheetCtl;
extern TASK_CTL taskCtl;
extern KEYBOARD_CTL keyboardCtl;


SHEET* bgSheet, *wndSheet, *testSheet;
extern TIM* task_timer;
TIM *bTim;
int a = 0, b = 0, c = 0;
char printBuf[64];
extern int32 mt_tr;
int kk = 0, t = 0;

typedef struct AFILEINFO{
	uint8 name[8], ext[3], type;
	uint8 reserve[10];
	uint16 time, date, clustno;
	uint32 size;
}AFILEINFO;


void task_b_main(SHEET *bgSheet, TASK* curTask)
{
	timer_add(100, &bTim);
	
	sprintf(printBuf, "[%d]%d, %d, %d", curTask, running, sleep, stopped);
	puts_str(bgSheet, printBuf, WHITE, 0, 348);
	sheet_add_redraw_region(0, 348, 100, 364);
	for (;;) {
		
		fill_box(bgSheet, GREEN, 500, 516, 800, 532);
		sprintf(printBuf, "%d|%d, %d, %d", mt_tr, timerCtl.timecount, timerCtl.sortedEnd, timerCtl.timeoutEnd, timerCtl.timerPos);
		puts_str(bgSheet, printBuf, WHITE, 500 + kk, 516);
		sheet_add_redraw_region(500, 516, 800, 532);
		
		if(bTim->isUsing == TRUE && bTim->isTimeout == TRUE) {
			fill_box(bgSheet, GREEN, 400, 400, 500, 416);
			sprintf(printBuf, "%d", b);
			puts_str(bgSheet, printBuf, WHITE, 400, 400);
			sheet_add_redraw_region(400, 400, 500, 416);
			timer_set_timeout(bTim, 100);
		}
		b++;
		task_sleep(curTask, 0);
	}
	// 不能有 return 
}

void task_c_main(SHEET *bgSheet, TASK* curTask)
{
	RECT wndRect;
	WND* wnd;
	TIM *cTim;
	int32 posX = 0, posY = 0, posXMax = 0, posYMax = 0;
	uint8 data, tmp, tmp1;
	boolean lastRC = TRUE;
	AFILEINFO* finfo = (AFILEINFO*)(ADR_DISKIMG + 0x002600);
	
	uint8 cmd[128];
	uint8 cmdLength = 0;
	
	wndRect.topLeftX = 100;
	wndRect.topLeftY = 300;
	wndRect.bottomRightX = 700;
	wndRect.bottomRightY = 700;
	
	wnd_create(wndRect, "Cmd", icon_heart, &wnd, draw_wnd2);
	sheet_add_redraw_region(300, 300, 600, 500);
	timer_add(100, &cTim);

	for(posXMax = 0; wnd->contentRect.topLeftX + 9 + posXMax < wnd->contentRect.bottomRightX; posXMax += 8);
	for(posYMax = 0; wnd->contentRect.topLeftY + 16 + posYMax < wnd->contentRect.bottomRightY; posYMax += 16);
	while (wnd->isUsing == TRUE) {
		if(lastRC == TRUE) {
			put_ascii(wnd->wndSheet, '>', WHITE, wnd->contentRect.topLeftX + 1 + posX, wnd->contentRect.topLeftY + 1 + posY);
			posX += 8;
			lastRC = FALSE;
		}
		
		if(cTim->isUsing == TRUE && cTim->isTimeout == TRUE) {
			c++;
			if(c % 2 == 0)
				put_ascii(wnd->wndSheet, '_', WHITE, wnd->contentRect.topLeftX + 1 + posX, wnd->contentRect.topLeftY + 1 + posY);
			else
				fill_box(wnd->wndSheet, BLACK, wnd->contentRect.topLeftX + 1 + posX, wnd->contentRect.topLeftY + 1 + posY, wnd->contentRect.topLeftX + 1 + posX + 8, wnd->contentRect.topLeftY + 1 + posY + 16);
//			sheet_draw_sub(wnd->contentRect.topLeftX + 1 + posX + wnd->wndRect.topLeftX, wnd->contentRect.topLeftY + 1 + posY + wnd->wndRect.topLeftY, wnd->contentRect.topLeftX + 1 + posX + 8 + wnd->wndRect.topLeftX, wnd->contentRect.topLeftY + 1 + posY + 16 +  + wnd->wndRect.topLeftY);
			timer_set_timeout(cTim, 100);
		}

		if(GetFromLoopArray(wnd->keyboardBuffer, &data) == TRUE) {
			if(data == ASC_CR) {			//接收到回车
				lastRC = TRUE;
				
				fill_box(wnd->wndSheet, BLACK, wnd->contentRect.topLeftX + 1 + posX, wnd->contentRect.topLeftY + 1 + posY, wnd->contentRect.topLeftX + 1 + posX + 8, wnd->contentRect.topLeftY + 1 + posY + 16);
				posX = 0;
				posY += 16;
				
				// 判断滚动
				if(posY + wnd->contentRect.topLeftY + 1 + 16 > wnd->contentRect.bottomRightY) {
					copy_buf(wnd->wndSheet, posXMax, posYMax - 16, wnd->contentRect.topLeftX + 1, wnd->contentRect.topLeftY + 1, wnd->contentRect.topLeftX + 1, wnd->contentRect.topLeftY + 1 + 16);
					fill_box(wnd->wndSheet, BLACK, wnd->contentRect.topLeftX + 1, posYMax + wnd->contentRect.topLeftY - 15, wnd->contentRect.topLeftX + 1 + posXMax, posYMax + wnd->contentRect.topLeftY + 1);
					posY -= 16;
				}

				cmd[cmdLength++] = 0;
				if(strcmp(cmd, "mem") == 0) {
					sprintf(printBuf, "Mem totalSize:%d KB", mem_getTotalSize() / 1024);
					puts_str(wnd->wndSheet, printBuf, WHITE, wnd->contentRect.topLeftX + 1 + posX, wnd->contentRect.topLeftY + 1 + posY);
					posY += 16;
					// 判断滚动
					if(posY + wnd->contentRect.topLeftY + 1 + 16 > wnd->contentRect.bottomRightY) {
						copy_buf(wnd->wndSheet, posXMax, posYMax - 16, wnd->contentRect.topLeftX + 1, wnd->contentRect.topLeftY + 1, wnd->contentRect.topLeftX + 1, wnd->contentRect.topLeftY + 1 + 16);
						fill_box(wnd->wndSheet, BLACK, wnd->contentRect.topLeftX + 1, posYMax + wnd->contentRect.topLeftY - 15, wnd->contentRect.topLeftX + 1 + posXMax, posYMax + wnd->contentRect.topLeftY + 1);
						posY -= 16;
					}
					sprintf(printBuf, "Mem freeSize:%d KB", mem_getFreeSum() / 1024);
					puts_str(wnd->wndSheet, printBuf, WHITE, wnd->contentRect.topLeftX + 1 + posX, wnd->contentRect.topLeftY + 1 + posY);
					posY += 16;
					// 判断滚动
					if(posY + wnd->contentRect.topLeftY + 1 + 16 > wnd->contentRect.bottomRightY) {
						copy_buf(wnd->wndSheet, posXMax, posYMax - 16, wnd->contentRect.topLeftX + 1, wnd->contentRect.topLeftY + 1, wnd->contentRect.topLeftX + 1, wnd->contentRect.topLeftY + 1 + 16);
						fill_box(wnd->wndSheet, BLACK, wnd->contentRect.topLeftX + 1, posYMax + wnd->contentRect.topLeftY - 15, wnd->contentRect.topLeftX + 1 + posXMax, posYMax + wnd->contentRect.topLeftY + 1);
						posY -= 16;
					}
					sprintf(printBuf, "Mem usedSize:%d KB", mem_getUsedSum() / 1024);
					puts_str(wnd->wndSheet, printBuf, WHITE, wnd->contentRect.topLeftX + 1 + posX, wnd->contentRect.topLeftY + 1 + posY);
					posY += 16;
				}
				else if(strcmp(cmd, "help") == 0) {
					puts_str(wnd->wndSheet, "This is help. nothing to tell~", WHITE, wnd->contentRect.topLeftX + 1 + posX, wnd->contentRect.topLeftY + 1 + posY);
					posY += 16;
				}
				else if(strcmp(cmd, "clear") == 0) {
					posX = 0;
					posY = 0;
					fill_box(wnd->wndSheet, BLACK, wnd->contentRect.topLeftX + 1 + posX, wnd->contentRect.topLeftY + 1 + posY, wnd->contentRect.bottomRightX, wnd->contentRect.bottomRightY);
				}
				else if(strcmp(cmd, "dir") == 0) {
					for(tmp = 0; tmp < 224; tmp++) {
						if(finfo[tmp].name[0] == 0x00) break;
						if(finfo[tmp].name[0] != 0xe5) {
							sprintf(printBuf, "filename.ext   %7d", finfo[tmp].size);
							for(tmp1 = 0; tmp1 < 8; tmp1++) {
								printBuf[tmp1] = finfo[tmp].name[tmp1];
							}
							printBuf[9] = finfo[tmp].ext[0];
							printBuf[10] = finfo[tmp].ext[1];
							printBuf[11] = finfo[tmp].ext[2];
							
							puts_str(wnd->wndSheet, printBuf, WHITE, wnd->contentRect.topLeftX + 1 + posX, wnd->contentRect.topLeftY + 1 + posY);
							posY += 16;
							// 判断滚动
							if(posY + wnd->contentRect.topLeftY + 1 + 16 > wnd->contentRect.bottomRightY) {
								copy_buf(wnd->wndSheet, posXMax, posYMax - 16, wnd->contentRect.topLeftX + 1, wnd->contentRect.topLeftY + 1, wnd->contentRect.topLeftX + 1, wnd->contentRect.topLeftY + 1 + 16);
								fill_box(wnd->wndSheet, BLACK, wnd->contentRect.topLeftX + 1, posYMax + wnd->contentRect.topLeftY - 15, wnd->contentRect.topLeftX + 1 + posXMax, posYMax + wnd->contentRect.topLeftY + 1);
								posY -= 16;
							}
						}
					}
				}
				else {
					puts_str(wnd->wndSheet, "Bad Command", WHITE, wnd->contentRect.topLeftX + 1 + posX, wnd->contentRect.topLeftY + 1 + posY);
					posY += 16;
				}
				cmdLength = 0;
			}
			else if(data == ASC_BS) {			//接收到退格
				cmdLength --;
				if(cmdLength < 0) cmdLength = 0;
				// 删掉光标
				fill_box(wnd->wndSheet, BLACK, wnd->contentRect.topLeftX + 1 + posX, wnd->contentRect.topLeftY + 1 + posY, wnd->contentRect.topLeftX + 1 + posX + 8, wnd->contentRect.topLeftY + 1 + posY + 16);
				// 删掉之前的字母
				posX -= 8;
				if(posX <= 0 && posY == 0) {
					posX = 0;
				}
				if(posX < 0 && posY > 0) {
					posY -= 16;
					posX = posXMax - 8;
				}
				fill_box(wnd->wndSheet, BLACK, wnd->contentRect.topLeftX + 1 + posX, wnd->contentRect.topLeftY + 1 + posY, wnd->contentRect.topLeftX + 1 + posX + 8, wnd->contentRect.topLeftY + 1 + posY + 16);
//				sheet_draw_sub(wnd->contentRect.topLeftX + 1 + posX + wnd->wndRect.topLeftX, wnd->contentRect.topLeftY + 1 + posY + wnd->wndRect.topLeftY, wnd->contentRect.topLeftX + 1 + posX + 8 + wnd->wndRect.topLeftX, wnd->contentRect.topLeftY + 1 + posY + 16 +  + wnd->wndRect.topLeftY);
			}
			else {
				cmd[cmdLength++] = data;
				
				fill_box(wnd->wndSheet, BLACK, wnd->contentRect.topLeftX + 1 + posX, wnd->contentRect.topLeftY + 1 + posY, wnd->contentRect.topLeftX + 1 + posX + 8, wnd->contentRect.topLeftY + 1 + posY + 16);
				put_ascii(wnd->wndSheet, data, WHITE, wnd->contentRect.topLeftX + 1 + posX, wnd->contentRect.topLeftY + 1 + posY);
//				sheet_draw_sub(wnd->contentRect.topLeftX + 1 + posX + wnd->wndRect.topLeftX, wnd->contentRect.topLeftY + 1 + posY + wnd->wndRect.topLeftY, wnd->contentRect.topLeftX + 1 + posX + 8 + wnd->wndRect.topLeftX, wnd->contentRect.topLeftY + 1 + posY + 16 +  + wnd->wndRect.topLeftY);
				posX += 8;
				if(wnd->contentRect.topLeftX + 9 + posX >= wnd->contentRect.bottomRightX) {
					posX = 0;
					posY += 16;
				}
			}
			// 判断滚动
			if(posY + wnd->contentRect.topLeftY + 1 + 16 > wnd->contentRect.bottomRightY) {
				copy_buf(wnd->wndSheet, posXMax, posYMax - 16, wnd->contentRect.topLeftX + 1, wnd->contentRect.topLeftY + 1, wnd->contentRect.topLeftX + 1, wnd->contentRect.topLeftY + 1 + 16);
				fill_box(wnd->wndSheet, BLACK, wnd->contentRect.topLeftX + 1, posYMax + wnd->contentRect.topLeftY - 15, wnd->contentRect.topLeftX + 1 + posXMax, posYMax + wnd->contentRect.topLeftY + 1);
				posY -= 16;
			}
		}
		sheet_add_redraw_region(wnd->wndRect.topLeftX, wnd->wndRect.topLeftY, wnd->wndRect.bottomRightX, wnd->wndRect.bottomRightY);

		task_sleep(curTask, 0);
	}
	while(1);
	// 不能有 return 
}

void task_d_main(SHEET *bgSheet, TASK* curTask)
{
	RECT wndRect;
	WND_CONSOLE wnd;
	boolean re;
	
	wndRect.topLeftX = 100;
	wndRect.topLeftY = 0;
	wndRect.bottomRightX = 700;
	wndRect.bottomRightY = 600;
	
	re = wnd_console_create(wndRect, "ACmd", icon_heart, &wnd);
//	*((int*)0x0FEC) = (int)&wnd;						//console
		
	wnd_console_add_cmd(&wnd, "mem", "Show the memory useage.", (CONSOLE_CMD_FUNCTION)mem);
	wnd_console_add_cmd(&wnd, "wnd", "Show the wnd state.", (CONSOLE_CMD_FUNCTION)showWnd);
	wnd_console_add_cmd(&wnd, "help", "Show cmd reference", (CONSOLE_CMD_FUNCTION)help);
	wnd_console_add_cmd(&wnd, "ls", "Show files under directory", (CONSOLE_CMD_FUNCTION)ls);
	wnd_console_add_cmd(&wnd, "clear", "Clear screen", (CONSOLE_CMD_FUNCTION)clear);
	wnd_console_add_cmd(&wnd, "type", "Show the Content of file", (CONSOLE_CMD_FUNCTION)type);
	wnd_console_add_cmd(&wnd, "hex", "Show the Hex Content of file", (CONSOLE_CMD_FUNCTION)hex);
	wnd_console_add_cmd(&wnd, "top", "Show the tasks.", (CONSOLE_CMD_FUNCTION)top);

	wnd_console_daemon(&wnd, curTask);
	while(1);
}

void task_e_main(SHEET *bgSheet, TASK* curTask)
{
	RECT wndRect;
	WND_CONSOLE wnd;
	boolean re;
	
	wndRect.topLeftX = 150;
	wndRect.topLeftY = 0;
	wndRect.bottomRightX = 750;
	wndRect.bottomRightY = 500;
	//boolean wnd_create(IN RECT wndSize, IN int8* title, IN int8* icon, OUT WND** wnd, draw_wnd func);
	re = wnd_console_create(wndRect, "ECmd", icon_heart, &wnd);
//	*((int*)0x0FEC) = (int)&wnd;						//console

	wnd_console_add_cmd(&wnd, "mem", "Show the memory useage.", (CONSOLE_CMD_FUNCTION)mem);
	wnd_console_add_cmd(&wnd, "wnd", "Show the wnd state.", (CONSOLE_CMD_FUNCTION)showWnd);
	wnd_console_add_cmd(&wnd, "help", "Show cmd reference", (CONSOLE_CMD_FUNCTION)help);
	wnd_console_add_cmd(&wnd, "ls", "Show files under directory", (CONSOLE_CMD_FUNCTION)ls);
	wnd_console_add_cmd(&wnd, "clear", "Clear screen", (CONSOLE_CMD_FUNCTION)clear);
	wnd_console_add_cmd(&wnd, "type", "Show the Content of file", (CONSOLE_CMD_FUNCTION)type);
	wnd_console_add_cmd(&wnd, "hex", "Show the Hex Content of file", (CONSOLE_CMD_FUNCTION)hex);
	wnd_console_add_cmd(&wnd, "top", "Show the tasks.", (CONSOLE_CMD_FUNCTION)top);

	wnd_console_daemon(&wnd, curTask);
	while(1);
}

struct SEGMENT_DESCRIPTOR *gdt = (struct SEGMENT_DESCRIPTOR *) ADDR_GDT;

void OS_Init(void)
{
	BOOTINFO* info;
	
	int32 screenWidth, screenHeight;
	uint8* bgBuf, *resVram;
	boolean re[2];
	uint32 tmpAddr;

	InitPeripheralBuffer();
	
	init_gdtidt();
	init_pic();
	io_sti();		// 恢复中断
	tim_init();
	io_out8(PIC0_IMR, 0xf8); /* PIT和PIC1和键盘设置为许可(11111000) */
	io_out8(PIC1_IMR, 0xef); /* 鼠标设置为许可(11101111) */
	
	info = (BOOTINFO*) ADR_BOOTINFO;
	screenHeight = info->screenHeight;
	screenWidth = info->screenWidth;
	
	init_palette();
	mem_init();
	re[0] = mem_alloc(768 * 1024, &tmpAddr);
	resVram = (uint8*)tmpAddr;
	sheet_init(resVram);
	
	InitMouse();
	InitKeyboard();
	
	re[1] = mem_alloc(768 * 1024, &tmpAddr);
	bgBuf = (uint8*)tmpAddr;
	
	//screenWidth * screenHeight
	sheet_add(bgBuf, screenWidth, screenHeight, 0, 0, NONE_COL, &bgSheet);

	fill_box(bgSheet, DARKGRASS, 0, 0, info->screenWidth, info->screenHeight);
	if(re[0] == FALSE || re[1] == FALSE) {
		fill_box(bgSheet, RED, 0, 0, info->screenWidth, info->screenHeight);
	}
}

void OS_Main(void)
{
	uint32 tmpAddr;
	TIM* testTim, *cntTIM;
	int8 buf[10];
	RECT wndRect;
	WND* myWnd1, *myWnd2, *myWnd3, *myWnd4, *myConsoleWnd, *topWnd;
	TASK	*taskA, *taskB, *taskC, *taskD;
	WND_CONSOLE* console;

	OS_Init();
	
	fill_box(bgSheet, BLACK, 0, 0, 160, 16);
	sprintf(printBuf, "MemVol:%dMB", mem_getTotalSize() / (1024 * 1024));
	puts_str(bgSheet, printBuf, WHITE, 0, 0);

	timer_add(300, &testTim);
	timer_add(50, &cntTIM);
	timer_add(100, &cntTIM);
	
	sprintf(printBuf, "%d,%d,%d,%d", testTim->timeout, testTim->isUsing, testTim->isTimeout, timerCtl.sortedEnd);
	puts_str(bgSheet, printBuf, WHITE, 0, 184);

	wndRect.topLeftX = 400;
	wndRect.topLeftY = 200;
	wndRect.bottomRightX = 800;
	wndRect.bottomRightY = 400;
	
	wnd_create(wndRect, "Nike", icon_heart, &myWnd1, draw_wnd1);
	wnd_create(wndRect, "Adidas", icon_heart, &myWnd2, draw_wnd1);
	wnd_create(wndRect, "New balance", icon_heart, &myWnd3, draw_wnd2);
	wnd_create(wndRect, "HelloWorld!HelloWorld!HelloWorld!", icon_heart, &myWnd4, draw_wnd1);

	multiTask_init();
	
	//Task A
	mem_alloc(64 * 1024, &tmpAddr);
	tmpAddr += 64 * 1024 - 12;
	*((int*)(tmpAddr + 4)) = (int)bgSheet;
	task_alloc("Task A", (int32)&task_b_main, tmpAddr, 0x00000202, 1, &taskA);
	*((int*)(tmpAddr + 8)) = (int)taskA;
	taskA->tss.cs = 2 * 8;
	task_run(taskA);

	//Task B
	/*
	mem_alloc(64 * 1024, &tmpAddr);
	tmpAddr += 64 * 1024 - 12;
	*((int*)(tmpAddr + 4)) = (int)bgSheet;
	task_alloc("Task B", (int32)&task_c_main, tmpAddr, 0x00000202, 1, &taskB);
	*((int*)(tmpAddr + 8)) = (int)taskB;
	taskB->tss.cs = 2 * 8;		//目前必须为 2 × 8
	task_run(taskB);
	*/

	//Task C
	mem_alloc(64 * 1024, &tmpAddr);
	tmpAddr += 64 * 1024 - 12;
	*((int*)(tmpAddr + 4)) = (int)bgSheet;
	task_alloc("Task Console", (int32)&task_d_main, tmpAddr, 0x00000202, 1, &taskC);
	*((int*)(tmpAddr + 8)) = (int)taskC;
	taskC->tss.cs = 2 * 8;		//目前必须为 2 × 8
	task_run(taskC);
	
	
	//Task D
	mem_alloc(64 * 1024, &tmpAddr);
	tmpAddr += 64 * 1024 - 12;
	*((int*)(tmpAddr + 4)) = (int)bgSheet;
	task_alloc("Task ConsoleD", (int32)&task_e_main, tmpAddr, 0x00000202, 1, &taskD);
	*((int*)(tmpAddr + 8)) = (int)taskD;
	taskD->tss.cs = 2 * 8;		//目前必须为 2 × 8
	task_run(taskD);



	sprintf(printBuf, "1(%d)%d, %d, %d", taskCtl.taskNum, taskCtl.runningTasksEnd, taskCtl.stoppedTasksEnd, taskCtl.sleepTasksEnd);
	puts_str(bgSheet, printBuf, WHITE, 0, 300);	
	sprintf(printBuf, "2(%d)%d, %d, %d", taskCtl.nowRunningTaskPos, taskCtl.runningTasks[0]->status, taskA->status, taskB->status);
	puts_str(bgSheet, printBuf, WHITE, 0, 316);
	sprintf(printBuf, "3(%d)%d, %d, %d", taskA, running, sleep, stopped);
	puts_str(bgSheet, printBuf, WHITE, 0, 332);
	sheet_add_redraw_region(0, 300, 100, 348);

	sheet_draw_all();	
	while(1){

		if(cntTIM->isUsing == TRUE && cntTIM->isTimeout) {
			fill_box(bgSheet, BLACK, 300, 300, 350, 350);
			sprintf(printBuf, "%d", a);
			puts_str(bgSheet, printBuf, WHITE, 300, 300);
			sheet_add_redraw_region(300, 300, 350, 350);
			timer_set_timeout(cntTIM, 100);
		}
		a++;

		if(testTim->isUsing == TRUE && testTim->isTimeout) {
			testTim->isUsing = FALSE;
			sprintf(printBuf, "timer out!");
			puts_str(bgSheet, printBuf, WHITE, 0, 96);
			sheet_add_redraw_region(0, 96, 100, 112);
		}
		
		fill_box(bgSheet, BLACK, 500, 500, 800, 516);
		sprintf(printBuf, "%d|%d, %d, %d", mt_tr, timerCtl.sortedEnd, timerCtl.timeoutEnd, timerCtl.timerPos);
		puts_str(bgSheet, printBuf, WHITE, 500, 500);
//		sprintf(printBuf, "%d,%d,%d", sheetCtl.sortedSheet[0]->buf, sheetCtl.sortedSheet[1]->buf, sheetCtl.sortedSheet[2]->buf);
//		puts_str(bgSheet, printBuf, WHITE, 500, 516);
		sheet_add_redraw_region(500, 500, 800, 516);
		 
		fill_box(bgSheet, GREEN, 500, 548, 800, 564);
		sprintf(printBuf, "%d|%d, %d", sheetCtl.redraw_list_length, sheetCtl.redraw_list_startPos, sheetCtl.redraw_list_endPos);
		puts_str(bgSheet, printBuf, WHITE, 500, 548);
		sheet_draw_sub(500, 548, 800, 564);

		if(KeyboardGetChar(buf, 1)) {
			fill_box(bgSheet, BLACK, 0, 232, 100, 248);
			puts_str(bgSheet, buf, WHITE, 0, 232);
			sheet_add_redraw_region(0, 232, 100, 248);
			topWnd = wnd_get_top();
			if(topWnd != NULL) {
				PutIntoLoopArray(topWnd->keyboardBuffer, buf[0]);
			}
		}
		MouseKeyboardDeamon();
		sheet_draw_deamon();
		if(keyboardCtl.WinOn == TRUE && taskC->tss.ss0 != 0) {
			console = (WND_CONSOLE*)*((int*)0xFEC);
			console_puts(console, "\nBreak(key) :\n");
			io_cli();
			taskC->tss.eax = (int) &(taskC->tss.esp0);
			taskC->tss.eip = (int) asm_end_app;
			io_sti();
			keyboardCtl.WinOn = FALSE;
		}
	}
	// 不能有 return 
}

